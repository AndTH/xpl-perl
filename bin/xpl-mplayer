#!/usr/bin/perl -w

# $Id: xpl-mplayer 56 2005-12-14 08:36:22Z beanz $

=head1 NAME

xpl-mplayer - Perl script for an xPL mplayer application

=head1 SYNOPSIS

  # show usage message
  xpl-mplayer -h

  # start the mplayer application on first ethernet interface in verbose mode
  xpl-mplayer -i eth0 -v

=head1 DESCRIPTION

This script is an xPL client that interfaces with an mplayer controller.

=cut

use strict;
use warnings;
use English qw/-no_match_vars/;
use FileHandle;
use IO::Pipe;
use Getopt::Std;
use POSIX ":sys_wait_h";
use xPL::Client;
$|=1; # autoflush helps debugging

sub HELP_MESSAGE {
  my $msg = shift || q{};
  die
qq{Usage: $0 [flags] [options]
where valid flags are:
  -h - show this help text
  -v - verbose mode
and valid options are (default shown in brackets):
  -i if0     - the inferface for xPL messages (first non-loopback or loopback)
  -l list    - the playlist
  -s 0/1     - shuffle mode (1=shuffle)
  -c 0/1/... - ALSA card number (0)
  -C ctrl    - ALSA mixer control ('PCM')
$msg
};
}

my %opt = ();
getopts('hvi:b:l:s:c:C:', \%opt);
if (exists $opt{'h'}) {
  HELP_MESSAGE()
}
$opt{'s'} = 1 unless (exists $opt{'s'});
$opt{'l'} = "/etc/ha/conf/playlist.m3u" unless (exists $opt{'l'});
$opt{'c'} = 0 unless (exists $opt{'c'});
$opt{'C'} = 'PCM' unless (exists $opt{'C'});

my %args =
  (
   vendor_id => "bnz",
   device_id => "mplayer",
  );
if (exists $opt{'i'}) {
  $args{interface} = $opt{'i'};
}
if (exists $opt{'v'}) {
  $args{verbose} = $opt{'v'};
}

my $pl = [];
my $pl_index = -1;
load_list($opt{'l'}, $opt{'s'});

# Create an xPL Client object
my $xpl = xPL::Client->new(%args) or die "Failed to create xPL::Client\n";

# Add a callback to receive all incoming xPL messages
$xpl->add_xpl_callback(id => 'mplayer', callback => \&xpl_in);

my $mode = "idle";
my $track = "unknown";
my $artist = "unknown";
my $album = "unknown";
my $buf = "";
my $pid;
my $waitedpid;
my $rh;
my $wh;

sub sigchld {
  my $child;
  while (($waitedpid = waitpid(-1,WNOHANG)) > 0) {
    print STDERR "Reaped ", $waitedpid, ($? ? " with exit $?" : '')
      if ($opt{'v'});
    if (defined $pid && $waitedpid == $pid) {
      undef $pid;
      cleanup();
      play() if ($mode eq 'play');
    }
  }
  $SIG{CHLD} = \&sigchld;
}
$SIG{CHLD} = \&sigchld;

sub cleanup {
  if ($pid) {
    kill 9, $pid;
    undef $pid;
  }
  if ($rh) {
    $xpl->remove_input($rh);
    undef $rh;
  }
  undef $wh;
}

# Run the main loop
$xpl->main_loop();

sub play_file {
  my $file = shift;

  print STDERR "Playing $file\n";
  $rh = IO::Pipe->new;
  $wh = IO::Pipe->new;

  $pid = fork;
  if ($pid) {
    # parent
    $rh->reader();
    $wh->writer();
    $wh->autoflush(1);
    $xpl->add_input(handle => $rh, callback => \&mplayer_reader);
  } elsif (defined $pid) {
    # child
    $rh->writer();
    $rh->autoflush(1);
    $wh->reader();
    my $wfd = $rh->fileno;
    my $rfd = $wh->fileno;
    open(STDIN,"<&$rfd") || die "dup of stdin failed: $!";
    open(STDOUT,">&=$wfd") || die "dup of stdout failed: $!";
    open(STDERR,"+>&$wfd") || die "dup of stderr failed: $!";
    exec(qw/mplayer -vo null -quiet -slave
            -noconsolecontrols -nojoystick -nolirc/, @ARGV, $file) or
              die "Failed to exec mplayer: $!\n";
  } else {
    die "Fork failed: $!\n";
  }
}

=head2 C<mplayer_reader( )>

This is the callback that reads the output from the mplayer process.

=cut

sub mplayer_reader {
  my $bytes = $rh->sysread($buf, 512, length($buf));
  while ($buf =~ s/^(.*?)\n//) {
    $_ = $LAST_PAREN_MATCH;
#    print STDERR "M: $_\n";
    if (/^\s+Name:\s+(.*?)\s*$/) {
      $track = $1;
    } elsif (/^\s+Artist:\s+(.*?)\s*$/) {
      $artist = $1;
      $xpl->send(message_type => 'xpl-cmnd',
                 class => 'osd.basic',
                 body =>
                 {
                  command => 'clear',
                  row => 1,
                  text => $track,
                 });
      $xpl->send(message_type => 'xpl-cmnd',
                 class => 'osd.basic',
                 body =>
                 {
                  command => 'write',
                  row => 2,
                  text => $artist,
                 });
    } elsif (/^\s+Album:\s+(.*?)\s*$/) {
      $album = $1;
    }
  }
  return 1;
}

=head2 C<xpl_in(%xpl_callback_parameters)>

This is the callback that processes incoming xPL messages.  It handles
a limited subset of the full audio.basic schema but could easily be
extended.

=cut

sub xpl_in {
  my %p = @_;
  my $msg = $p{message};
  my $peeraddr = $p{peeraddr};
  my $peerport = $p{peerport};

  if ($msg->message_type ne 'xpl-cmnd' ||
      $msg->class ne 'audio' ||
      $msg->class_type ne 'basic') {
    return 1;
  }
  my $command = $msg->command;
  print STDERR "Command: $command\n";
  if ($command =~ /^volume\s?\+(\d+)/) {
    change_volume(+1*$1);
  } elsif ($command =~ /^volume\s?\-(\d+)/) {
    change_volume(-1*$1);
  } elsif ($command =~ /^volume\s?(\d+)/) {
    set_volume($1);
  } elsif ($command =~ /^play$/ || $command =~ /^skip$/) {
    if ($mode eq "play") {
      skip();
    } else {
      play();
    }
  } elsif ($command =~ /^stop$/) {
    stop();
  }
  return 1;
}

=head2 C<change_volume( $inc )>

This method increments/decrements the current mixer volume.

=cut

sub change_volume {
  my $change = shift;
  my $vol = get_volume();
  return set_volume($vol+$change);
}

=head2 C<set_volume( $vol )>

This method changes the current mixer volume.

=cut

sub set_volume {
  my $vol = shift;
  my $pipe = IO::Pipe->new;
  $pipe->reader('amixer','-c', $opt{'c'}, 'sset', $opt{'C'}, $vol.'%');
  my $percent = 0;
  my $count = 0;
  while(<$pipe>) {
    if (/\[(\d+)%\]/) {
      $percent += $1;
      $count++;
    }
  }
  $pipe->close;
  $vol = $count ? $percent/$count : 0;
  print STDERR "New Volume = $vol\n";
  return $vol;
}

=head2 C<get_volume( )>

This method returns the current mixer volume.

=cut

sub get_volume {
  my $pipe = IO::Pipe->new;
  $pipe->reader('amixer','-c', $opt{'c'}, 'sget', $opt{'C'});
  my $percent = 0;
  my $count = 0;
  while(<$pipe>) {
    if (/\[(\d+)%\]/) {
      $percent += $1;
      $count++;
    }
  }
  $pipe->close;
  my $vol = $count ? $percent/$count : 0;
  print STDERR "Volume = $vol\n";
  return $vol;
}

=head2 C<play( )>

This method plays the next song from the playlist.

=cut

sub play {
  $mode = 'play';
  $pl_index += 1;
  $pl_index %= scalar @$pl;
  my $file = $pl->[$pl_index];
  play_file($file);
}

=head2 C<skip( )>

This method skips the current song.

=cut

sub skip {
  stop();
  play();
}

=head2 C<stop( )>

This method stops the mplayer player.

=cut

sub stop {
  $mode = 'idle';
  cleanup();
}

=head2 C<load_list( $file, [ $shuffle ])>

This method loads a playlist.

=cut

sub load_list {
  my $file = shift;
  my $shuffle = shift;
  my $fh = FileHandle->new($file) || return [];
  my @array = <$fh>;
  chomp(@array);
  fisher_yates_shuffle(\@array) if ($shuffle);
  print STDERR "Playlist contains ", scalar @array, " items\n";
  return $pl = \@array;
}

=head2 C<fisher_yates_shuffle( \@array )>

This method is the shuffle described in the Perl Cookbook.

=cut

sub fisher_yates_shuffle {
  my $array = shift;
  my $i;
  for ($i = @$array; --$i; ) {
    my $j = int rand ($i+1);
    next if $i == $j;
    @$array[$i,$j] = @$array[$j,$i];
  }
}

# send a 'hbeat.end' message on exit
END { defined $xpl && $xpl->send_hbeat_end(); }

=head1 TODO

=over 4

=item
  cache volume if we read it recently to avoid having to fork for
  reading if multiple small increments are message are received in
  quick succession.

=item
  support 'back' command

=item
  support 'requests'

=item
  support 'status=next' request by parsing output from:

   mplayer -no... -frames 0 -ao null -vo null file' output

=back

=head1 SEE ALSO

xPL::Client(3), xPL::Listener(3), Audio::Mixer(3)

Project website: http://www.xpl-perl.org.uk/

=head1 AUTHOR

Mark Hindess, E<lt>xpl-perl@beanz.uklinux.netE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2005 by Mark Hindess

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.7 or,
at your option, any later version of Perl 5 you may have available.

=cut

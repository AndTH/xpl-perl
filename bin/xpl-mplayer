#!/usr/bin/perl -w

# $Id$

=head1 NAME

xpl-mplayer - Perl script for an xPL mplayer application

=head1 SYNOPSIS

  xpl-mplayer [flags] [options]
  where valid flags are:
    -h - show this help text
    -v - verbose mode
  and valid options are (default shown in brackets):
    -i if0     - the interface for xPL messages (first non-loopback or loopback)
    -l list    - the playlist
    -s 0/1     - shuffle mode (1=shuffle)
    -c 0/1/... - ALSA card number (0)
    -C ctrl    - ALSA mixer control ('PCM')

  # start the mplayer application on first ethernet interface in verbose mode
  xpl-mplayer -i eth0 -v

=head1 DESCRIPTION

This script is an xPL client that interfaces with an mplayer controller.

B<This script is deprecated and will not be in the next release unless
someone asks me to continue maintaining it.  L<xpl-mpd> is recommended
instead.>

=cut

use strict;
use warnings;
use English qw/-no_match_vars/;
use DirHandle;
use FileHandle;
use IO::Pipe;
use Getopt::Long;
use Pod::Usage;
use POSIX ":sys_wait_h";
use xPL::Client;
$|=1; # autoflush helps debugging

my %args = ( vendor_id => 'bnz', device_id => 'mplayer', );
my %opt = ();
my $verbose;
my $interface;
my $help;
my $man;
my $shuffle = 1;
my $playlist = '/etc/xplperl/playlist.m3u';
my $card = 0;
my $ctrl = 'PCM';
GetOptions('verbose+' => \$verbose,
           'interface=s' => \$interface,
           'define=s' => \%opt,
           'help|?|h' => \$help,
           'man' => \$man,
           'shuffle:i' => \$shuffle,
           'playlist|l=s' => \$playlist,
           'card|c=s' => \$card,
           'control|ctrl|C=s' => \$ctrl,
           ) or pod2usage(2);
pod2usage(1) if ($help);
pod2usage(-exitstatus => 0, -verbose => 2) if ($man);

$args{'interface'} = $interface if ($interface);
$args{'verbose'} = $verbose if ($verbose);

my $pl = {};
load_list($playlist, $shuffle);

# Create an xPL Client object
my $xpl = xPL::Client->new(%args, %opt) or die "Failed to create xPL::Client\n";

# Add a callback to receive all incoming xPL messages
$xpl->add_xpl_callback(id => 'mplayer', callback => \&xpl_in,
                       filter => {
                        message_type => 'xpl-cmnd',
                        class => 'audio',
                        class_type => 'basic',
                       });

my $mode = "idle";
my $quick = 0;
my $track = "unknown";
my $artist = "unknown";
my $album = "unknown";
my $buf = "";
my $pid;
my $waitedpid;
my $rh;
my $wh;

sub sigchld {
  my $child;
  while (($waitedpid = waitpid(-1,WNOHANG)) > 0) {
    print STDERR "Reaped ", $waitedpid, ($? ? " with exit $?" : '')
      if ($verbose);
    if (defined $pid && $waitedpid == $pid) {
      undef $pid;
      cleanup();
      play() if ($mode eq 'play');
    }
  }
  $SIG{CHLD} = \&sigchld;
}
$SIG{CHLD} = \&sigchld;

sub cleanup {
  if ($pid) {
    kill 9, $pid;
    undef $pid;
  }
  if ($rh) {
    $xpl->remove_input($rh);
    undef $rh;
  }
  undef $wh;
}

# Run the main loop
$xpl->main_loop();

sub play_file {
  my $file = shift;

  print STDERR "Playing $file\n";
  $rh = IO::Pipe->new;
  $wh = IO::Pipe->new;

  $pid = fork;
  if ($pid) {
    # parent
    $rh->reader();
    $wh->writer();
    $wh->autoflush(1);
    $xpl->add_input(handle => $rh, callback => \&mplayer_reader);
  } elsif (defined $pid) {
    # child
    $rh->writer();
    $rh->autoflush(1);
    $wh->reader();
    my $wfd = $rh->fileno;
    my $rfd = $wh->fileno;
    open(STDIN,"<&$rfd") || die "dup of stdin failed: $!";
    open(STDOUT,">&=$wfd") || die "dup of stdout failed: $!";
    open(STDERR,"+>&$wfd") || die "dup of stderr failed: $!";
    exec(qw/mplayer -vo null -quiet -slave
            -noconsolecontrols -nojoystick -nolirc/, @ARGV, $file) or
              die "Failed to exec mplayer: $!\n";
  } else {
    die "Fork failed: $!\n";
  }
}

=head2 C<mplayer_reader( )>

This is the callback that reads the output from the mplayer process.

=cut

sub mplayer_reader {
  my $bytes = $rh->sysread($buf, 512, length($buf));
  while ($buf =~ s/^(.*?)\n//) {
    $_ = $LAST_PAREN_MATCH;
#    print STDERR "M: $_\n";
    if (/^\s+Name:\s+(.*?)\s*$/) {
      $track = $1;
    } elsif (/^\s+Artist:\s+(.*?)\s*$/) {
      $artist = $1;
      $xpl->send(message_type => 'xpl-cmnd',
                 class => 'osd.basic',
                 body =>
                 {
                  command => 'clear',
                  row => 1,
                  text => $track,
                 });
      $xpl->send(message_type => 'xpl-cmnd',
                 class => 'osd.basic',
                 body =>
                 {
                  command => 'write',
                  row => 2,
                  text => $artist,
                 });
    } elsif (/^\s+Album:\s+(.*?)\s*$/) {
      $album = $1;
    }
  }
  return 1;
}

=head2 C<xpl_in(%xpl_callback_parameters)>

This is the callback that processes incoming xPL messages.  It handles
a limited subset of the full audio.basic schema but could easily be
extended.

=cut

sub xpl_in {
  my %p = @_;
  my $msg = $p{message};
  my $peeraddr = $p{peeraddr};
  my $peerport = $p{peerport};

  my $command = $msg->command;
  print STDERR "Command: $command\n";
  if ($command =~ /^volume\s?\+(\d+)/) {
    change_volume(+1*$1);
  } elsif ($command =~ /^volume\s?\-(\d+)/) {
    change_volume(-1*$1);
  } elsif ($command =~ /^volume\s?(\d+)/) {
    set_volume($1);
  } elsif ($command =~ /^play$/ || $command =~ /^skip$/) {
    if ($quick) {
      # switch play list
      next_list();
      $xpl->remove_timer('quick');
    }
    $quick = 1;
    $xpl->add_timer(id => 'quick',
                     timeout => 2,
                    callback => sub { $quick = 0; return; });
    if ($mode eq "play") {
      skip();
    } else {
      play();
    }
  } elsif ($command =~ /^stop$/) {
    stop();
  }
  return 1;
}

=head2 C<change_volume( $inc )>

This method increments/decrements the current mixer volume.

=cut

sub change_volume {
  my $change = shift;
  my $vol = get_volume();
  return set_volume($vol+$change);
}

=head2 C<set_volume( $vol )>

This method changes the current mixer volume.

=cut

sub set_volume {
  my $vol = shift;
  my $pipe = IO::Pipe->new;
  $pipe->reader('amixer','-c', $card, 'sset', $ctrl, $vol.'%');
  my $percent = 0;
  my $count = 0;
  while(<$pipe>) {
    if (/\[(\d+)%\]/) {
      $percent += $1;
      $count++;
    }
  }
  $pipe->close;
  $vol = $count ? $percent/$count : 0;
  print STDERR "New Volume = $vol\n";
  return $vol;
}

=head2 C<get_volume( )>

This method returns the current mixer volume.

=cut

sub get_volume {
  my $pipe = IO::Pipe->new;
  $pipe->reader('amixer','-c', $card, 'sget', $ctrl);
  my $percent = 0;
  my $count = 0;
  while(<$pipe>) {
    if (/\[(\d+)%\]/) {
      $percent += $1;
      $count++;
    }
  }
  $pipe->close;
  my $vol = $count ? $percent/$count : 0;
  print STDERR "Volume = $vol\n";
  return $vol;
}

=head2 C<play( )>

This method plays the next song from the playlist.

=cut

sub play {
  $mode = 'play';
  my $current = $pl->{lists}->[$pl->{index}];
  $current->{index} += 1;
  $current->{index} %= scalar @{$current->{tracks}};
  my $file = $current->{tracks}->[$current->{index}];
  play_file($file);
}

=head2 C<next_list( )>

This method switches to the next play list.

=cut

sub next_list {
  $pl->{index} += 1;
  $pl->{index} %= scalar @{$pl->{lists}};
  print STDERR "Playlist is now ", $pl->{lists}->[$pl->{index}]->{file}, "\n";
}

=head2 C<skip( )>

This method skips the current song.

=cut

sub skip {
  stop();
  play();
}

=head2 C<stop( )>

This method stops the mplayer player.

=cut

sub stop {
  $mode = 'idle';
  cleanup();
}

=head2 C<load_list( $file, [ $shuffle ])>

This method loads a playlist.

=cut

sub load_list {
  my $file = shift;
  my $shuffle = shift;
  $pl = { index => -1, lists => [] };
  if (-d $file) {
    my $dh = DirHandle->new($file);
    foreach my $sub (sort $dh->read()) {
      next unless ($sub =~ /\.m3u$/);
      _load_list($pl, $file.'/'.$sub, $shuffle);
    }
    return $pl;
  } else {
    return _load_list($pl, $file, $shuffle);
  }
}

=head2 C<_load_list( $playlist, $file, [ $shuffle ])>

This method loads a playlist.

=cut

sub _load_list {
  my $playlist = shift;
  my $file = shift;
  my $shuffle = shift;
  my %rec = ( file => $file, index => -1, tracks => []);
  my $fh = FileHandle->new($file) || return \%rec;
  my @array = <$fh>;
  chomp(@array);
  fisher_yates_shuffle(\@array) if ($shuffle);
  print STDERR "Playlist $file contains ", scalar @array, " items\n";
  $rec{tracks} = \@array;
  push @{$pl->{lists}}, \%rec;
  return $pl;
}

=head2 C<fisher_yates_shuffle( \@array )>

This method is the shuffle described in the Perl Cookbook.

=cut

sub fisher_yates_shuffle {
  my $array = shift;
  my $i;
  for ($i = @$array; --$i; ) {
    my $j = int rand ($i+1);
    next if $i == $j;
    @$array[$i,$j] = @$array[$j,$i];
  }
}

# send a 'hbeat.end' message on exit
END { defined $xpl && $xpl->send_hbeat_end(); }

=head1 TODO

=over 4

=item
  cache volume if we read it recently to avoid having to fork for
  reading if multiple small increments are message are received in
  quick succession.

=item
  support 'back' command

=item
  support 'requests'

=item
  support 'status=next' request by parsing output from:

   mplayer -no... -frames 0 -ao null -vo null file' output

=back

=head1 SEE ALSO

xPL::Client(3), xPL::Listener(3), Audio::Mixer(3)

Project website: http://www.xpl-perl.org.uk/

=head1 AUTHOR

Mark Hindess, E<lt>soft-xpl-perl@temporalanomaly.comE<gt>

=head1 COPYRIGHT

Copyright (C) 2007, 2008 by Mark Hindess

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.7 or,
at your option, any later version of Perl 5 you may have available.

=cut

#!/usr/bin/perl -w

# $Id$

=head1 NAME

xpl-rfxcom-trans - Perl script for an xPL RFXCOM RF transmitter application

=head1 SYNOPSIS

  xpl-rfxcom-trans [flags] [options] <device>
  where valid flags are:
    -h - show this help text
    -v - verbose mode
    -r - receiver connected
    -f - enable Flamingo/Koppla RF
    -h - enable Harrison RF
    -k - enable KlikOn-KlikOff, NEXA, ELRO AB600, Domia Lite RF
    -x - DISable X10/security RF
  and valid options are (default shown in brackets):
    -i if0  - the interface for xPL messages (first non-loopback or loopback)
    -B baud - the baud rate (4800)

  # start the rfxcom-trans application on first ethernet interface in
  # verbose mode
  xpl-rfxcom-trans -i eth0 -v

=head1 DESCRIPTION

This script is an xPL client that interfaces with a RFXCOM RF
transmitter.  It currently only suppports the 'number of bits to xmit
and up to 48bits'-mode.

=cut

use strict;
use warnings;
use English qw/-no_match_vars/;
use FileHandle;
use Getopt::Long;
use Pod::Usage;
use IO::Socket::INET;
use Time::HiRes;
use xPL::Client;
use xPL::RF qw/:all/;
use xPL::X10 qw/:all/;
$|=1; # autoflush helps debugging

my %args = ( vendor_id => 'bnz', device_id => 'rfxcomt', );
my %opt = ();
my $verbose;
my $interface;
my $help;
my $man;
my $baud = 4800;
my $receiver_connected;
my $flamingo;
my $harrison;
my $koko;
my $no_x10;
GetOptions('verbose+' => \$verbose,
           'interface=s' => \$interface,
           'baud=i' => \$baud,
           'define=s' => \%opt,
           'help|?|h' => \$help,
           'man' => \$man,
           'receiver_connected' => \$receiver_connected,
           'flamingo' => \$flamingo,
           'harrison' => \$harrison,
           'koko' => \$koko,
           'no_x10|x' => \$no_x10,
          ) or pod2usage(2);
pod2usage(1) if ($help);
pod2usage(-exitstatus => 0, -verbose => 2) if ($man);
$args{'interface'} = $interface if ($interface);
$args{'verbose'} = $verbose if ($verbose);

my $dev = shift or pod2usage(-message => "The device parameter is required",
                             -exitstatus => 1);

# Create an xPL Client object
my $xpl = xPL::Client->new(%args, %opt) or die "Failed to create xPL::Client\n";

# Add a callback to receive all incoming xPL messages
$xpl->add_xpl_callback(id => 'rfxcom', callback => \&xpl_in,
                       filter =>
                       {
                        message_type => 'xpl-cmnd',
                        class => 'x10',
                        class_type => 'basic',
                       });

my $last_read = 0;
my $buf = q{};
my $rf = xPL::RF->new(source => $xpl->id) or
  die "Failed to create RF decode object\n";

my $fh;
if ($dev =~ /\//) {
  # TODO: use Device::SerialPort?
  system("/bin/stty -F $dev ospeed $baud pass8 raw -echo >/dev/null") == 0 or
    die "Setting serial port with stty failed: $!\n";
  $fh = FileHandle->new;
  sysopen($fh, $dev,O_RDWR|O_NOCTTY|O_NDELAY)
    or die "Cannot open serial connection on device '$dev'\n";
  $fh->autoflush(1);
  binmode($fh);
} else {
  $dev .= ':10001' unless ($dev =~ /:/);
  $fh = IO::Socket::INET->new($dev)
    or die "Cannot TCP connection to device at '$dev'\n";
}

$xpl->add_input(handle => $fh, callback => \&rfxcom_reader);

{
  package msg;
  sub new {
    my $pkg = shift;
    my %p = @_;
    bless \%p, $pkg;
    unless (exists $p{hex} or exists $p{raw}) {
      return;
    }
    return \%p;
  }
  sub hex {
    $_[0]->{hex} or $_[0]->{hex} = unpack "H*", $_[0]->{raw};
  }
  sub raw {
    $_[0]->{raw} or $_[0]->{raw} = pack "H*", $_[0]->{hex};
  }
  sub str {
    $_[0]->hex.($_[0]->{desc} ? ": ".$_[0]->{desc} : '');
  }
  use overload ( '""'  => \&str);
  1;
}

my @queue = ();
push @queue,
  $receiver_connected ?
  msg->new(hex => 'F033F033',
           desc => 'variable length mode with receiver connected') :
  msg->new(hex => 'F037F037',
           desc => 'variable length mode with no receiver connected');
push @queue,
  msg->new(hex => 'F03CF03C', desc => 'enabling harrison') if ($harrison);
push @queue,
  msg->new(hex => 'F03DF03D', desc => 'enabling klikon-klikoff') if ($koko);
push @queue,
  msg->new(hex => 'F03EF03E', desc => 'enabling flamingo') if ($flamingo);
push @queue,
  msg->new(hex => 'F03FF03F', desc => 'disabling x10') if ($no_x10);
my $waiting = undef;
send_rfxcom(msg->new(hex => 'F030F030', desc => 'init/version check'));

# Run the main loop
$xpl->main_loop();

=head2 C<xpl_in(%xpl_callback_parameters)>

This is the callback that processes incoming xPL messages.  It handles
the incoming x10.basic schema messages.

=cut

sub xpl_in {
  my %p = @_;
  my $msg = $p{message};
  my $peeraddr = $p{peeraddr};
  my $peerport = $p{peerport};

  if ($msg->house) {
    foreach (split //, $msg->house) {
      queue_rfxcom(msg->new(raw => encode(command => $msg->command,
                                          house => $msg->house),
                            desc => $msg->house.' '.$msg->command));
    }
  } elsif ($msg->device) {
    foreach (split /,/, $msg->device) {
      my ($house, $unit) = /^([a-p])(\d+)$/i or next;
      queue_rfxcom(msg->new(raw => encode(command => $msg->command,
                                          house => $house,
                                          unit => $unit),
                            desc => $house.$unit.' '.$msg->command));
    }
  } else {
    warn "Invalid x10.basic message:\n  ", $msg->summary, "\n";
  }
  return 1;
}

=head2 C<rfxcom_reader()>

This is the callback that processes output from the RFXCOM transmitter.
It is responsible for reading the 'ACK' messages and sending out any
queued transmit messages.

=cut

sub rfxcom_reader {
  my $buf = '';
  my $bytes = $fh->sysread($buf, 512, 0);
  unless ($bytes) {
    warn "Device closed\n";
    exit;
  }
  print "received: ", unpack("H*", $buf), "\n";
  $waiting = 0;
  $xpl->remove_timer("wait_for_ack");
  send_rfxcom() if (scalar @queue);
  return 1;
}

sub queue_rfxcom {
  my $msg = shift;
  if (!$waiting) {
    return send_rfxcom($msg);
  }
  print "queued:   ", $msg->str, "\n";
  push @queue, $msg;
  return -(scalar @queue);
}

sub send_rfxcom {
  my $msg = shift || shift @queue;
  print "sending:  ", $msg->str, "\n";
  my $raw = $msg->raw;
  syswrite($fh, $raw, length($raw));
  $fh->flush();
  $waiting = 1;
  $xpl->add_timer(id => "wait_for_ack", timeout => 2,
                  callback => sub {
                    print STDERR "No ack!\n";
                    $xpl->remove_timer("wait_for_ack");
                    send_rfxcom($receiver_connected ?
                                msg->new(hex => 'F033F033',
                                         desc =>
                                         'variable length mode with receiver connected') :
                                msg->new(hex => 'F037F037',
                                         desc =>
                                         'variable length mode with no receiver connected'));
                    1;
              });
}

sub encode {
  return pack "C5", 32, @{xPL::X10::to_rf(@_)};
}

# send a 'hbeat.end' message on exit
END { defined $xpl && $xpl->send_hbeat_end(); }

=head1 SEE ALSO

xPL::Client(3), xPL::Listener(3)

Project website: http://www.xpl-perl.org.uk/

W800 website: http://www.wgldesigns.com/w800.html

=head1 AUTHOR

Mark Hindess, E<lt>xpl-perl@beanz.uklinux.netE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2007 by Mark Hindess

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.7 or,
at your option, any later version of Perl 5 you may have available.

=cut

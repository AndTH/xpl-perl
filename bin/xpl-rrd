#!/usr/bin/perl -w

# $Id$

=head1 NAME

xpl-rrd - Perl script for an xPL application that logs data to rrd files

=head1 SYNOPSIS

  # show usage message
  xpl-rrd -h

  # start the rrd listening and broadcasting on first ethernet
  # interface in verbose mode
  xpl-rrd -i eth0 -v

=head1 DESCRIPTION

This script is an xPL client that logs known message types

=cut

use strict;
use warnings;
use Getopt::Std;
use xPL::Client;
use DB_File;
use RRDs;
use Fcntl;
use FileHandle;

$|=1; # autoflush helps debugging

sub HELP_MESSAGE {
  my $msg = shift || "";
  die
qq{Usage: $0 [flags] [options] <rrd-dir>
where valid flags are:
  -h - show this help text
  -v - verbose client mode
and valid options are (default shown in brackets):
  -i if0 - the inferface for xPL messages (first non-loopback or loopback)
  -x map - map device names to more friendly aliases (none)
           N.B. This is a temporary hack to get around lack of config
           support this will be removed in future.
$msg
};
}

my %opt = ();
getopts('hvi:x:', \%opt);
HELP_MESSAGE() if (exists $opt{'h'});
my %args = ( vendor_id => "bnz", device_id => "rrdgraph", );
my $verbose = exists $opt{'v'};
my $device_map = $opt{'x'};
if (exists $opt{'i'}) {
  $args{interface} = $opt{'i'};
}
if ($verbose) {
  $args{verbose} = $opt{'v'};
}
my $rrd_dir =
  shift or HELP_MESSAGE("Requires path to rrd directory parameter");
my $state_db = $rrd_dir.'/state.db';

mkdir $rrd_dir, 0755 unless (-d $rrd_dir);
my %state;
my $tie_h = tie %state, "DB_File", $state_db, O_CREAT|O_RDWR, 0666, $DB_HASH;
die "Failed to open $state_db file: $!\n" unless ($tie_h);

my %map = ();
if ($device_map) {
  my $fh = FileHandle->new('<'.$device_map) or
    die "Failed to open $device_map: $!\n";
  while(<$fh>) {
    next if (/^\s*$/ || /^\s*#/); # skip blank or comment lines
    chomp;
    if (/^(.*)\s*=\s*(.*)$/) {
      $map{$1} = $2;
    } else {
      warn "$device_map line $. invalid line: $_\n";
    }
  }
  $fh->close;
}

my %last;

# Create an xPL Client object
my $xpl = xPL::Client->new(%args) or die "Failed to create xPL::Client\n";

# Add a callback to receive all incoming xPL messages
$xpl->add_xpl_callback(id => "xpl",
                       self_skip => 0, targetted => 0,
                       callback => \&xpl_msg);
$xpl->add_timer(id => "rrd", timeout => 120, callback => \&rrd);

# Run the main loop
$xpl->main_loop();

# The callback to log the incoming messages
sub xpl_msg {
  my %p = @_;
  my $msg = $p{message};
  my $peeraddr = $p{peeraddr};
  my $peerport = $p{peerport};
  my $time = time;
  my $c = chr(0);

  if ($msg->class eq "sensor" && $msg->class_type eq "basic" &&
      $msg->device && $msg->type eq "temp") {
    my $dev = exists $map{$msg->device} ? $map{$msg->device} : $msg->device;
    delete $state{$dev};
    $state{$dev.'/temp'} = join($c, $time, $msg->current, 1, -20, 120);
    $tie_h->sync;
  } elsif ($msg->class eq "sensor" && $msg->class_type eq "basic" &&
      $msg->device && $msg->type eq "humidity") {
    my $dev = exists $map{$msg->device} ? $map{$msg->device} : $msg->device;
    delete $state{$dev};
    $state{$dev.'/humidity'} = join($c, $time, $msg->current, 1, 0, 100);
    $tie_h->sync;
  }
  return 1;
}

sub rrd {
  my $time = time;
  my %data = ();
  foreach my $dev (keys %state) {
    update_rrd($time, $dev, split(chr(0), $state{$dev}));
  }
  return 1;
}

sub update_rrd {
  my ($time, $dev, $last, $val, $fill, $min, $max) = @_;
  my $rrd = $rrd_dir.'/';
  my $var = "value";
  if ($dev =~ m!^(.*)/([^/]+)$!) {
    $var = $2;
    $rrd .= $1.'/';
    mkdir $rrd, 0755 unless (-d $1);
    $rrd .= $2.'.rrd';
    my $old = $rrd_dir.'/'.$1.'.rrd';
    if (-f $old) {
      print STDERR "Trying to rename $old to $rrd\n";
      rename($old, $rrd) or die "Failed to rename: $!\n";
    }
  } else {
    $rrd .= $dev.'.rrd';
  }
  unless (-f $rrd) {
    make_rrd($rrd, $time, $dev, $last, $var, $val, $fill, $min, $max) or return;
  }
  my $t = $fill ? $time : $last;
  if ($last{$rrd} && $last{$rrd} >= $t) {
    return 1;
  }
  RRDs::update($rrd, '-t', $var, $t.':'.$val);
  my $err = RRDs::error;
  if ($err) {
    warn "ERROR updating $rrd: $err\n";
    return;
  }
  return 1;
}

sub make_rrd {
  my ($rrd, $time, $dev, $last, $var, $val, $fill, $min, $max) = @_;
  RRDs::create($rrd,
               "--step", 60,
               "DS:$var:GAUGE:300:$min:$max",
               "RRA:AVERAGE:0.5:1:6000", # 100 hours
               "RRA:AVERAGE:0.5:60:2400", # every hour for 100 days
               "RRA:AVERAGE:0.5:1440:400", # every day for 400 days
               "RRA:AVERAGE:0.5:10080:2080", # every week for 40 years
               "RRA:MIN:0.5:1:6000",
               "RRA:MIN:0.5:60:2400",
               "RRA:MIN:0.5:1440:400",
               "RRA:MIN:0.5:10080:2080",
               "RRA:MAX:0.5:1:6000",
               "RRA:MAX:0.5:60:2400",
               "RRA:MAX:0.5:1440:400",
               "RRA:MAX:0.5:10080:2080",
              );
  my $err = RRDs::error;
  if ($err) {
    warn "ERROR creating $rrd: $err\n";
    return;
  }
  return 1;
}

# send a "hbeat.end" message on exit
END { defined $xpl && $xpl->send_hbeat_end(); }

=head1 SEE ALSO

xPL::Client(3), xPL::Listener(3)

Project website: http://www.xpl-perl.org.uk/

=head1 AUTHOR

Mark Hindess, E<lt>xpl-perl@beanz.uklinux.netE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2005 by Mark Hindess

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.7 or,
at your option, any later version of Perl 5 you may have available.

=cut

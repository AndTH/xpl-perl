#!/usr/bin/perl -w

# $Id$

=head1 NAME

xpl-owfs - Perl script for an xPL interface to the one-wire filesystem

=head1 SYNOPSIS

  xpl-owfs [flags] [options] <owfs-mountpoint>
  where valid flags are:
    -h - show this help text
    -v - verbose mode
  and valid options are (default shown in brackets):
    -i if0  - the interface for xPL messages (first non-loopback or loopback)

  # start the owfs application on first ethernet interface in verbose mode
  xpl-owfs -i eth0 -v

=head1 DESCRIPTION

This script is an xPL client that interfaces with the one-wire
filesystem.  It supports the use of control.basic messages with
current fields set to 'high', 'low' or 'pulse' of devices with PIO
files.  It also sends sensor.basic messages for devices with
'temperature', 'humidity', 'current', 'counters.A' or 'counters.B'
files.  For more details, see the table at http://owfs.sourceforge.net/ow_table.html

=cut

use strict;
use warnings;
use English qw/-no_match_vars/;
use DirHandle;
use FileHandle;
use Getopt::Long;
use Pod::Usage;
use xPL::Client;
$|=1; # autoflush helps debugging

my %args = ( vendor_id => 'bnz', device_id => 'owfs', );
my %opt = ();
my $verbose;
my $interface;
my $help;
my $man;
GetOptions('verbose+' => \$verbose,
           'interface=s' => \$interface,
           'define=s' => \%opt,
           'help|?|h' => \$help,
           'man' => \$man,
          ) or pod2usage(2);
pod2usage(1) if ($help);
pod2usage(-exitstatus => 0, -verbose => 2) if ($man);
$args{'interface'} = $interface if ($interface);
$args{'verbose'} = $verbose if ($verbose);

my $ow_dir = shift or
 pod2usage(-message => 'The owfs mount parameter is required',
           -exitstatus => 1);

# Create an xPL Client object
my $xpl = xPL::Client->new(%args, %opt) or die "Failed to create xPL::Client\n";

# Add a callback to receive all incoming xPL messages
$xpl->add_xpl_callback(id => 'owfs', callback => \&xpl_in,
                       filter => {
                                  message_type => 'xpl-cmnd',
                                  class => 'control',
                                  class_type => 'basic',
                                  type => 'output',
                                 });

# sanity check the inputs immediately and periodically so we keep
# the current state sane even when owfs is unplugged, etc.
$xpl->add_timer(id => 'owfs-read', timeout => -120,
                callback => sub { owfs_reader(); 1; });

my %state;

# Run the main loop
$xpl->main_loop();

=head2 C<xpl_in(%xpl_callback_parameters)>

This is the callback that processes incoming xPL messages.  It handles
the incoming control.basic schema messages.

=cut

sub xpl_in {
  my %p = @_;
  my $msg = $p{message};
  my $peeraddr = $p{peeraddr};
  my $peerport = $p{peerport};

  my $device = uc $msg->device;
  my $current = lc $msg->current;
  unless ($device =~ /^[0-9A-F]{2}\.[0-9A-F]+$/) {
    return 1;
  }
  if ($current eq 'high') {
    owfs_write($device.'/PIO', 1);
  } elsif ($current eq 'low') {
    owfs_write($device.'/PIO', 0);
  } elsif ($current eq 'pulse') {
    owfs_write($device.'/PIO', 1);
    select(undef,undef,undef,0.15);
    owfs_write($device.'/PIO', 0);
  }
  return 1;
}

=head2 C<owfs_write( $file, $value )>

This function writes the given value to the named file in the 1-wire
file system.

=cut

sub owfs_write {
  my ($file, $value) = @_;
  my $fh = FileHandle->new('>'.$ow_dir.'/'.$file) or return;
  print STDERR "Writing $value to $file\n" if ($verbose);
  $fh->print($value);
  $fh->flush();
  return;
}

=head2 C<owfs_reader()>

This is the callback that processes output from the OWFS.  It is
responsible for sending out the sensor.basic xpl-trig messages.

=cut

sub owfs_reader {
  my $devices = find_ow_devices($ow_dir);
  my $found;
  foreach my $dev (@$devices) {
    foreach my $rec ([ "temperature", "temp" ],
                     [ 'humidity', 'humidity' ],
                     [ 'counters.A', 'count', 0 ],
                     [ 'counters.B', 'count', 1 ],
                     [ 'current', 'current' ]) {
      my ($filebase, $type, $index) = @$rec;
      my $file = $dev.'/'.$filebase;
      next unless (-f $file);
      my $value = read_ow_file($file) or next;
      $found++;
      my $old = $state{$dev}->{$filebase};
      my $message_type =
        (defined $old && $value eq $old) ? "xpl-stat" : "xpl-trig";
      $state{$dev}->{$filebase} = $value;
      my $id = $dev;
      $id =~ s!.*/!!;
      send_xpl( $message_type, $id, $type, $value, $index);
    }
  }
  unless ($found) {
    warn "No devices found?\n";
    return 1;
  }
  return 1;
}

=head2 C<send_xpl( $message_type, $device, $type, $current, $index )>

This functions is used to send out sensor.basic xPL messages with
the state of one-wire sensors.

=cut

sub send_xpl {
  my $message_type = shift;
  my $device = shift;
  my $type = shift;
  my $current = shift;
  my $index = shift;
  my %args =
    (
     message_type => $message_type,
     class => 'sensor.basic',
     body =>
     {
      device => (defined $index ? $device.'.'.$index : $device),
      type => $type,
      current => $current,
     },
    );
  print STDERR "Sending $device\[$type]=$current\n" if ($verbose);
  return $xpl->send(%args);
}

=head2 C<find_ow_devices( $ow_dir )>

This functions is used to find all devices present in the one-wire
file system.  It returns a list reference of paths to device
directories.

=cut

sub find_ow_devices {
  my $ow_dir = shift;
  my $res = shift || [];
  my $dh = DirHandle->new($ow_dir) or do {
    warn "Failed to open ow dir, $ow_dir: $!\n";
    return $res;
  };
  foreach my $dev ($dh->read) {
    if ($dev =~ /^[0-9a-f]{2}\.[0-9a-f]{12}$/i) {
      push @$res, $ow_dir.'/'.$dev;
      foreach my $sub (qw/main aux/) {
        my $new_dir = $ow_dir.'/'.$dev.'/'.$sub;
        find_ow_devices($new_dir, $res) if (-d $new_dir);
      }
    }
  }
  $dh->close;
  return $res;
}

sub read_ow_file {
  my $file = shift;
  my $fh = FileHandle->new("<".$file) || return;
  my $value = <$fh>;
  chomp($value);
  $value =~ s/\s+$//;
  $value =~ s/^\s+//;
  return $value;
}

# send a 'hbeat.end' message on exit
END { defined $xpl && $xpl->send_hbeat_end(); }

=head1 SEE ALSO

xPL::Client(3), xPL::Listener(3)

Project website: http://www.xpl-perl.org.uk/

OWFS website: http://owfs.sourceforge.net/

=head1 AUTHOR

Mark Hindess, E<lt>soft-xpl-perl@temporalanomaly.comE<gt>

=head1 COPYRIGHT

Copyright (C) 2006, 2008 by Mark Hindess

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.7 or,
at your option, any later version of Perl 5 you may have available.

=cut

Zen Automated Home (ZenAH)
--------------------------

ZenAH is a suite of tools that I have running my house.  One important
part of the tool set is the xPL Perl project[0] which I've already
made Open Source.  I want to release the ZenAH tools as Open Source
too but I'd like to thrash out some key issues about the design a
little before I clean it up to release the code.

Features
--------

Written in Perl.

Catalyst-based web interface - either HTML, HTML+ajax, or XUL for
firefox.

Instant message interface.  (I've not been able to use googletalk
directly but I have via the jabber.org service thanks to the
federation between these two networks.  This is at the early stages
at the moment, but I want to add support for gaim-encryption.)

Four types of rules:

  'xpl' - triggered by incoming xPL messages
  'timer' - triggered by time - either specified using simple interval,
            cron-style or DateTime::Event::Recurrence-style.
  'scene' - only triggered by other rules

The actions triggered by rules can consist of zero or more actions of
types:

  'xpl' - send an xPL message
  'debug' - echo debugging information to the log
  'scene' - trigger a 'scene' rule
  'enable' - enable a rule
  'disable' - disable a rule
  'sleep' - pause for specific time before processing the rest of the rule

So for instance, you might have a rule that detects the x10.basic
message 'on' that turns on an appliance, with an action to enable a
second rule to send a "warning appliance is on" message using an
osd.basic message every 30 seconds.  You'd then have a second rule to
detect the x10.basic off message.

All of the actions are processed with the Template Toolkit[1] meaning
that you can have loops, logic, etc.  Additionally, the action template
is passed a 'stash' of variables for use in the template.  The stash
contains things like:

  - the message for xPL message-triggered rules
  - the arguments for scene-triggered rules


The layout of the web interface is defined by a simple (but I hope
powerful) model based on Template Toolkit blocks.  Content is defined
somewhat recursively by blocks.  For instance, you might have:

 a 'content' block contain:
   a 'header' block (which contains no other blocks)
   a table of 'room' blocks, for each room in your house, each containing:
     the template code to look up the room name
     a list of 'device' blocks, for each device in the room, each containing:
       the template code to look up the device name
       template toolkit code to produce a list of buttons for that type of
       device.

At each level, there is a default block type that may be overriden so
you might have an html content block as the default but be able to override
it with a block that generates XUL to be rendered in Firefox.

The backend database - which is editable through the Catalyst web
interface - contains tables for:

  Devices, have many attributes and a type which in turn has many controls.
  For example, Lamp, with attribute unit=l3, type X10Lamp, with
  controls 'on', 'off', 'bright', 'dim', etc.

  Maps, each row has a type, a name and a value.  Each set of rows for
  a given type is essentially a dictionary or hash table.  This is
  used extensively to simplify the rules.  For example, instead of
  have a rule checking for the xpl message generated by the RF X10
  keyfob with unit code a3 to trigger lamp l3 and another for the xpl
  message generated by the RF X10 keyfob with unit code b4 to trigger
  lamp l4.  I have two rows in the table of type 'x10lamp_trigger'
  with names, a3 and b4 and values l3 and l4 respectively and a single
  rule that checks all incoming x10 messages against the Map table.

  Rooms, have many attributes and many devices.

  Templates, has a type and has many dependencies which are also templates.
  For instance, a template of type content might depend on templates of
  type header and one or more of type room.


[0] http://www.xpl-perl.org.uk/
[1] http://www.template-toolkit.org/
